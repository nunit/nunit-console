Task("Default")
    .Description("Default task if none specified by user")
    .IsDependentOn("Build");

Task("CheckHeaders")
    .Description("Check source files for valid copyright headers")
    .WithCriteria(() => !CommandLineOptions.NoBuild)
    .WithCriteria(() => !BuildSettings.SuppressHeaderCheck)
    .Does(() =>
    {
        var NoHeader = new List<FilePath>();
        var NonStandard = new List<FilePath>();
        var Exempted = new List<FilePath>();
        int examined = 0;

        var sourceFiles = GetFiles(BuildSettings.SourceDirectory + "**/*.cs");
        var exemptFiles = BuildSettings.ExemptFiles;
        foreach (var file in sourceFiles)
        {
            var path = file.ToString();

            // Ignore autogenerated files in an obj directory
            if (path.Contains("/obj/"))
                continue;

            // Ignore designer files
            if (path.EndsWith(".Designer.cs"))
                continue;

            // Ignore AssemblyInfo files
            if (SIO.Path.GetFileName(path) == "AssemblyInfo.cs")
                continue;

            examined++;
            var header = GetHeader(file);
            if (exemptFiles.Contains(file.GetFilename().ToString()))
                Exempted.Add(file);
            else if (header.Count == 0)
                NoHeader.Add(file);
            else if (!header.SequenceEqual(BuildSettings.StandardHeader))
                NonStandard.Add(file);
        }

        Information("\nSTANDARD HEADER\n");
        foreach (string line in BuildSettings.StandardHeader)
            Information(line);
        Information("");

        if (NoHeader.Count > 0)
        {
            Information("\nFILES WITH NO HEADER\n");
            foreach (var file in NoHeader)
                Information(RelPathTo(file));
        }

        if (NonStandard.Count > 0)
        {
            Information("\nFILES WITH A NON-STANDARD HEADER\n");
            foreach (var file in NonStandard)
            {
                Information(RelPathTo(file));
                Information("");
                foreach (string line in GetHeader(file))
                    Information(line);
                Information("");
            }
        }

        if (Exempted.Count > 0)
        {
            Information("\nEXEMPTED FILES (NO CHECK MADE)\n");
            foreach (var file in Exempted)
                Information(RelPathTo(file));
        }

        Information($"\nFiles Examined: {examined}");
        Information($"Missing Headers: {NoHeader.Count}");
        Information($"Non-Standard Headers: {NonStandard.Count}");
        Information($"Exempted Files: {Exempted.Count}");

        if (NoHeader.Count > 0 || NonStandard.Count > 0)
            throw new Exception("Missing or invalid file headers found");

        if (examined == 0)
            Warning("\nWARNING: There were no '*.cs' files in the source directory. Use of the 'CheckHeaders' task may not make sense for this project.");

        List<string> GetHeader(FilePath file)
        {
            var header = new List<string>();
            var lines = SIO.File.ReadLines(file.ToString());

            foreach (string line in lines)
            {
                if (!line.StartsWith("//"))
                    break;

                header.Add(line);
            }

            return header;
        }

        string RelPathTo(FilePath file)
        {
            int CD_LENGTH = Environment.CurrentDirectory.Length + 1;

            return file.ToString().Substring(CD_LENGTH);
        }
    });

Task("Clean")
    .Description("Clean output and package directories")
    .WithCriteria(() => !CommandLineOptions.NoBuild)
    .Does(() =>
    {
        foreach (var binDir in GetDirectories($"**/bin/{BuildSettings.Configuration}/"))
            CleanDirectory(binDir);

        CleanDirectory(BuildSettings.PackageDirectory);
        CleanDirectory(BuildSettings.ImageDirectory);

        DeleteFiles(BuildSettings.ProjectDirectory + "*.log");
    });

Task("CleanAll")
    .Description("Clean everything!")
    .Does(() =>
    {
        foreach (var binDir in GetDirectories("**/bin/"))
            CleanDirectory(binDir);

        CleanDirectory(BuildSettings.PackageDirectory);
        CleanDirectory(BuildSettings.ImageDirectory);

        DeleteFiles(BuildSettings.ProjectDirectory + "*.log");

        foreach (var dir in GetDirectories("src/**/obj/"))
            DeleteDirectory(dir, new DeleteDirectorySettings() { Recursive = true });
    });

Task("Restore")
    .Description("Restore referenced packages")
    .WithCriteria(() => BuildSettings.SolutionFile != null)
    .WithCriteria(() => !CommandLineOptions.NoBuild)
    .Does(() => {
        NuGetRestore(BuildSettings.SolutionFile, new NuGetRestoreSettings()
        {
            Source = new string[]   {
                "https://www.nuget.org/api/v2",
                "https://www.myget.org/F/nunit/api/v2" },
            Verbosity = BuildSettings.NuGetVerbosity
        });
    });

Task("Build")
    .WithCriteria(() => BuildSettings.SolutionFile != null)
    .WithCriteria(() => !CommandLineOptions.NoBuild)
    .IsDependentOn("Clean")
    .IsDependentOn("Restore")
    .IsDependentOn("CheckHeaders")
    .Description("Build the solution")
    .Does(() => {
        if (BuildSettings.BuildWithMSBuild)
            MSBuild(BuildSettings.SolutionFile, BuildSettings.MSBuildSettings);
        else
            DotNetBuild(BuildSettings.SolutionFile, BuildSettings.DotNetBuildSettings);
    });

Task("Test")
    .Description("Run unit tests")
    .IsDependentOn("Build")
    .Does(() => UnitTesting.RunAllTests());

Task("Package")
    .IsDependentOn("Build")
    .Description("Build, Install, Verify and Test all packages")
    .Does(() => {
        foreach (var package in BuildSettings.SelectedPackages)
            package.BuildVerifyAndTest();
    });

Task("Publish")
    .Description("Publish all packages for current branch")
    .IsDependentOn("Package")
    .Does(() => {
        if (BuildSettings.ShouldPublishRelease)
            PackageReleaseManager.Publish();
        else
            Information("Nothing to publish from this run.");
    });

// This task may be run independently when recovering from errors.
Task("PublishToMyGet")
    .Description("""
		Publishes packages to MyGet for a dev build. If not, or if the --nopush
		option was used, a message is displayed.
		""")
    .Does(() => PackageReleaseManager.PublishToMyGet());

// This task may be run independently when recovering from errors.
Task("PublishToNuGet")
    .Description("""
	Publishes packages to NuGet for an alpha, beta, rc or final release. If not,
	or if the --nopush option was used, a message is displayed.
	""")
    .Does(() => PackageReleaseManager.PublishToNuGet());

// This task may be run independently when recovering from errors.
Task("PublishToChocolatey")
    .Description("""
	Publishes packages to Chocolatey for an alpha, beta, rc or final release.
	If not, or if the --nopush option was used, a message is displayed.
	""")
    .Does(() => PackageReleaseManager.PublishToChocolatey());

Task("PublishSymbolsPackage")
    .Description("Re-publish a specific symbols package to NuGet after a failure")
    .Does(() => PackageReleaseManager.PublishSymbolsPackage());

Task("CreateDraftRelease")
    .Description("Create a draft release on GitHub")
    .Does(() => PackageReleaseManager.CreateDraftRelease());

Task("CreateProductionRelease")
    .Description("Create a production GitHub Release")
    .Does(() => PackageReleaseManager.CreateProductionRelease());

Task("ContinuousIntegration")
    .Description("Perform continuous integration run")
    .IsDependentOn("DumpSettings")
    .IsDependentOn("Build")
    .IsDependentOn("Test")
    .IsDependentOn("Package")
    .IsDependentOn("Publish")
    .IsDependentOn("CreateDraftRelease")
    .IsDependentOn("CreateProductionRelease");

Task("DotnetInfo")
    .Description("Displays info about dotnet as seen by the script")
    .Does(() =>
    {
        Dotnet.Display();
    });

Task("DumpSettings")
    .Description("Display BuildSettings properties")
    .Does(() =>
    {
        Console.WriteLine("\nTASKS");
        Console.WriteLine("Target:                       " + BuildSettings.Target);
        Console.WriteLine("TasksToExecute:               " + string.Join(", ", BuildSettings.TasksToExecute));

        Console.WriteLine("\nENVIRONMENT");
        Console.WriteLine("IsLocalBuild:                 " + BuildSettings.IsLocalBuild);
        Console.WriteLine("IsRunningOnWindows:           " + BuildSettings.IsRunningOnWindows);
        Console.WriteLine("IsRunningOnUnix:              " + BuildSettings.IsRunningOnUnix);
        Console.WriteLine("IsRunningOnGitHubActions:     " + BuildSettings.IsRunningOnGitHubActions);

        Console.WriteLine("\nVERSIONING");
        Console.WriteLine("PackageVersion:               " + BuildSettings.PackageVersion);
        Console.WriteLine("LegacyPackageVersion:         " + BuildSettings.LegacyPackageVersion);
        Console.WriteLine("AssemblyVersion:              " + BuildSettings.AssemblyVersion);
        Console.WriteLine("AssemblyFileVersion:          " + BuildSettings.AssemblyFileVersion);
        Console.WriteLine("AssemblyInformationalVersion: " + BuildSettings.AssemblyInformationalVersion);
        Console.WriteLine("SemVer:                       " + BuildSettings.BuildVersion.SemVer);
        Console.WriteLine("IsPreRelease:                 " + BuildSettings.BuildVersion.IsPreRelease);
        Console.WriteLine("PreReleaseLabel:              " + BuildSettings.BuildVersion.PreReleaseLabel);
        Console.WriteLine("PreReleaseSuffix:             " + BuildSettings.BuildVersion.PreReleaseSuffix);

        Console.WriteLine("\nDIRECTORIES");
        Console.WriteLine("Project:       " + BuildSettings.ProjectDirectory);
        Console.WriteLine("Output:        " + BuildSettings.OutputDirectory);
        Console.WriteLine("Source:        " + BuildSettings.SourceDirectory);
        Console.WriteLine("NuGet:         " + BuildSettings.NuGetDirectory);
        Console.WriteLine("Chocolatey:    " + BuildSettings.ChocolateyDirectory);
        Console.WriteLine("Package:       " + BuildSettings.PackageDirectory);
        Console.WriteLine("PackageTest:   " + BuildSettings.PackageTestDirectory);
        Console.WriteLine("NuGetTest:     " + BuildSettings.NuGetTestDirectory);
        Console.WriteLine("ChocoTest:     " + BuildSettings.ChocolateyTestDirectory);
        Console.WriteLine("PackageResult: " + BuildSettings.PackageResultDirectory);
        Console.WriteLine("NuGetResult:   " + BuildSettings.NuGetResultDirectory);
        Console.WriteLine("ChocoResult:   " + BuildSettings.ChocolateyResultDirectory);
        Console.WriteLine("Image:         " + BuildSettings.ImageDirectory);

        Console.WriteLine("\nBUILD");
        Console.WriteLine("Configuration:   " + BuildSettings.Configuration);

        Console.WriteLine("\nUNIT TESTS");
        Console.WriteLine("UnitTests:                 " + BuildSettings.UnitTests);
        Console.WriteLine("UnitTestRunner:            " + BuildSettings.UnitTestRunner?.GetType().Name ?? "<NUnitLiteRunner>");

        Console.WriteLine("\nPACKAGING");
        Console.WriteLine("PackageTestLevel:          " + BuildSettings.PackageTestLevel);
        Console.WriteLine("MyGetPushUrl:              " + BuildSettings.MyGetPushUrl);
        Console.WriteLine("NuGetPushUrl:              " + BuildSettings.NuGetPushUrl);
        Console.WriteLine("ChocolateyPushUrl:         " + BuildSettings.ChocolateyPushUrl);
        Console.WriteLine("MyGetApiKey:               " + (!string.IsNullOrEmpty(BuildSettings.MyGetApiKey) ? "AVAILABLE" : "NOT AVAILABLE"));
        Console.WriteLine("NuGetApiKey:               " + (!string.IsNullOrEmpty(BuildSettings.NuGetApiKey) ? "AVAILABLE" : "NOT AVAILABLE"));
        Console.WriteLine("ChocolateyApiKey:          " + (!string.IsNullOrEmpty(BuildSettings.ChocolateyApiKey) ? "AVAILABLE" : "NOT AVAILABLE"));
        Console.WriteLine("GitHubAccessToken:         " + (!string.IsNullOrEmpty(BuildSettings.GitHubAccessToken) ? "AVAILABLE" : "NOT AVAILABLE"));

        Console.WriteLine("\nPACKAGES");
        foreach (var package in BuildSettings.Packages)
        {
            Console.WriteLine(package.PackageId);
            Console.WriteLine("  PackageType:               " + package.PackageType);
            Console.WriteLine("  PackageFileName:           " + package.PackageFileName);
            Console.WriteLine("  PackageInstallDirectory:   " + package.PackageInstallDirectory);
            Console.WriteLine("  PackageTestDirectory:      " + package.PackageTestDirectory);
            Console.WriteLine("  ExtensionInstallDirectory: " + package.ExtensionInstallDirectory);
        }
        var selected = BuildSettings.SelectedPackages.Select(p => p.PackageId);
        Console.WriteLine("  SelectedPackages:          " + string.Join(", ", selected.ToArray()));

        Console.WriteLine("\nPUBLISHING");
        Console.WriteLine("ShouldPublishToMyGet:      " + BuildSettings.ShouldPublishToMyGet);
        Console.WriteLine("ShouldPublishToNuGet:      " + BuildSettings.ShouldPublishToNuGet);
        Console.WriteLine("ShouldPublishToChocolatey: " + BuildSettings.ShouldPublishToChocolatey);

        Console.WriteLine("\nRELEASING");
        Console.WriteLine("BranchName:                " + BuildSettings.BranchName);
        Console.WriteLine("IsReleaseBranch:           " + BuildSettings.IsReleaseBranch);
        Console.WriteLine("ShouldPublishToGitHub:     " + BuildSettings.ShouldPublishToGitHub);
    });
